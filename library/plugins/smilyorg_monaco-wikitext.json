{"title":"$:/plugins/smilyorg/monaco-wikitext","name":"Monaco Wikitext","description":"Monaco Wikitext Language Support","author":"Miha Lunar","version":"0.5.0","core-version":">=5.1.21","source":"https://github.com/smilyorg/tw5-monaco","plugin-type":"plugin","parent-plugin":"$:/plugins/smilyorg/monaco","list":"readme license","dependents":"","type":"application/json","text":"{\"tiddlers\":{\"$:/plugins/smilyorg/monaco-wikitext/completion.js\":{\"title\":\"$:/plugins/smilyorg/monaco-wikitext/completion.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/smilyorg/monaco-wikitext/completion.js\\ntype: application/javascript\\nmodule-type: monaco\\n\\nWikitext completion support\\n\\n\\\\*/\\n(function(){\\n    \\\"use strict\\\";\\n\\n    const { monaco } = require(\\\"$:/plugins/smilyorg/monaco/monaco.js\\\");\\n    const { LANGUAGE_ID } = require(\\\"$:/plugins/smilyorg/monaco-wikitext/language.js\\\");\\n    \\n    const MATCH_LINK = /(\\\\[\\\\[)([^\\\\|\\\\]]*)(\\\\|?)([^\\\\]]*)(\\\\]?\\\\]?)/;\\n    const MATCH_TRANSCLUSION = /({{)([^}]*)(}?}?)/;\\n\\n    monaco.languages.registerCompletionItemProvider(LANGUAGE_ID, {\\n        triggerCharacters: [\\\"[\\\", \\\"|\\\", \\\"{\\\"],\\n        resolveCompletionItem(item) {\\n            const title = item.label;\\n            const tiddler = $tw.wiki.getTiddler(title);\\n            if (!tiddler) {\\n                return null;\\n            }\\n            let source = tiddler.fields.text;\\n            if (!source) {\\n                return null;\\n            }\\n            const maxChars = 1000;\\n            if (source.length > maxChars) {\\n                source = source.substr(0, maxChars);\\n            }\\n            const html = $tw.wiki.renderText(\\\"text/html\\\", tiddler.fields.type, source);\\n            if (!html) {\\n                return null;\\n            }\\n            return {\\n                documentation: {\\n                    isTrusted: true,\\n                    supportHtml: true,\\n                    value: html,\\n                },\\n            }\\n        },\\n        provideCompletionItems(model, position, context) {\\n            const maxChars = 1000;\\n            const range = {\\n                startLineNumber: position.lineNumber,\\n                startColumn: Math.max(1, position.column - maxChars),\\n                endLineNumber: position.lineNumber,\\n                endColumn: position.column + maxChars,\\n            };\\n            const text = model.getValueInRange(range);\\n            const textPos = position.column - range.startColumn;\\n\\n            let linkStart = findNearestDoubleChar(text, textPos, \\\"[\\\");\\n            if (context.triggerKind == monaco.languages.CompletionTriggerKind.TriggerCharacter) {\\n                switch (context.triggerCharacter) {\\n                    case \\\"[\\\":\\n                        // When triggered by [, ignore if not double [\\n                        if (linkStart == -1 || linkStart != textPos-2) {\\n                            return null;\\n                        }\\n                        break;\\n                            \\n                    case \\\"|\\\":\\n                        // When triggered by |, ignore if not inside of link\\n                        if (linkStart == -1) {\\n                            return null;\\n                        }\\n                        break;\\n                }\\n            }\\n            \\n            if (linkStart != -1) {\\n                const linkSuggestions = getLinkSuggestions(text, linkStart, textPos, range);\\n                if (linkSuggestions) {\\n                    return {\\n                        incomplete: true,\\n                        suggestions: linkSuggestions,\\n                    };\\n                }\\n            }\\n            \\n            let transStart = findNearestDoubleChar(text, textPos, \\\"{\\\");\\n            // When triggered by {, ignore if not double {\\n            if (\\n                context.triggerKind == monaco.languages.CompletionTriggerKind.TriggerCharacter &&\\n                context.triggerCharacter == \\\"{\\\" &&\\n                (transStart == -1 || transStart != textPos-2)\\n            ) {\\n                return null;\\n            }\\n            if (transStart != -1) {\\n                const transSuggestions = getTransclusionSuggestions(text, transStart, textPos, range);\\n                if (transSuggestions) {\\n                    return {\\n                        incomplete: true,\\n                        suggestions: transSuggestions,\\n                    };\\n                }\\n            }\\n            \\n            return { suggestions: getSuggestionsFromAllTiddlers() };\\n        }\\n    });\\n\\n    function getSuggestionsFromAllTiddlers() {\\n        const suggestions = [];\\n        const titles = $tw.wiki.getTiddlers();\\n        for (let i = 0; i < titles.length; i++) {\\n            const title = titles[i];\\n            suggestions.push({\\n                kind: monaco.languages.CompletionItemKind.Field,\\n                label: title,\\n                insertText: `[[${title}]] `,\\n            })\\n        }\\n        return suggestions;\\n    }\\n\\n    function findNearestDoubleChar(text, start, char) {\\n        for (let i = start; i >= 1; i--) {\\n            if (text[i - 1] == char && text[i] == char) {\\n                return i - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    function getLinkSuggestions(text, start, cursor, range) {\\n        const contents = text.substr(start);\\n        const link = MATCH_LINK.exec(contents);\\n        if (!link || link.length == 0) {\\n            return null;\\n        }\\n        \\n        const end = start + link[0].length;\\n        if (cursor > end) {\\n            return null;\\n        }\\n\\n        let display = link[2];\\n        let pipe = link[3];\\n        let title = link[4];\\n        if (!title && !pipe) {\\n            title = display;\\n            display = \\\"\\\";\\n        }\\n        let titles = $tw.wiki.search(title, {\\n            field: \\\"title\\\"\\n        });\\n        \\n        const suggestions = [];\\n        for (let i = 0; i < titles.length; i++) {\\n            const title = titles[i];\\n            const systemTiddler = title.startsWith(\\\"$:/\\\");\\n            if (systemTiddler) {\\n                continue;\\n            }\\n            const insertText = `[[${display}${pipe}${title}]]`;\\n            suggestions.push({\\n                kind: monaco.languages.CompletionItemKind.Field,\\n                label: title,\\n                filterText: insertText,\\n                range: {\\n                    startLineNumber: range.startLineNumber,\\n                    endLineNumber: range.endLineNumber,\\n                    startColumn: range.startColumn + start,\\n                    endColumn: range.startColumn + end,\\n                },\\n                insertText: insertText,\\n            })\\n        }\\n        \\n        return suggestions;\\n    }\\n    \\n    function getTransclusionSuggestions(text, start, cursor, range) {\\n        const contents = text.substr(start);\\n        const trans = MATCH_TRANSCLUSION.exec(contents);\\n        console.log(MATCH_TRANSCLUSION, text, start, contents);\\n        if (!trans || trans.length == 0) {\\n            return null;\\n        }\\n        \\n        const end = start + trans[0].length;\\n        if (cursor > end) {\\n            return null;\\n        }\\n\\n        let title = trans[2];\\n        let titles = $tw.wiki.search(title, {\\n            field: \\\"title\\\"\\n        });\\n        \\n        const suggestions = [];\\n        for (let i = 0; i < titles.length; i++) {\\n            const title = titles[i];\\n            const systemTiddler = title.startsWith(\\\"$:/\\\");\\n            if (systemTiddler) {\\n                continue;\\n            }\\n            const insertText = `{{${title}}}`;\\n            suggestions.push({\\n                kind: monaco.languages.CompletionItemKind.Field,\\n                label: title,\\n                filterText: insertText,\\n                range: {\\n                    startLineNumber: range.startLineNumber,\\n                    endLineNumber: range.endLineNumber,\\n                    startColumn: range.startColumn + start,\\n                    endColumn: range.startColumn + end,\\n                },\\n                insertText: insertText,\\n            })\\n        }\\n        \\n        return suggestions;\\n    }\\n    \\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"monaco\"},\"$:/plugins/smilyorg/monaco-wikitext/highlight.js\":{\"title\":\"$:/plugins/smilyorg/monaco-wikitext/highlight.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/smilyorg/monaco-wikitext/highlight.js\\ntype: application/javascript\\nmodule-type: monaco\\n\\nWikitext highlight support\\n\\n\\\\*/\\n(function(){\\n    \\\"use strict\\\";\\n\\n    const { monaco } = require(\\\"$:/plugins/smilyorg/monaco/monaco.js\\\");\\n    const { LANGUAGE_ID } = require(\\\"$:/plugins/smilyorg/monaco-wikitext/language.js\\\");\\n    const { extractTokensFromTree } = require(\\\"$:/plugins/smilyorg/monaco-wikitext/parser.js\\\");\\n\\n    class State {\\n        clone() {\\n            return this;\\n        }\\n        equals(state) {\\n            return true;\\n        }\\n    }\\n\\n    monaco.languages.setTokensProvider(LANGUAGE_ID, {\\n        getInitialState() {\\n            return new State();\\n        },\\n        tokenize(line, state) {\\n            const parsed = $tw.wiki.parseText(\\\"text/vnd.tiddlywiki\\\", line);\\n            const tokens = [];\\n            let prevEnd = 0;\\n            extractTokensFromTree(parsed, (start, end, tokenType, tokenModifiers) => {\\n                if (prevEnd != start) {\\n                    tokens.push({\\n                        startIndex: prevEnd,\\n                        scopes: \\\"unknown\\\"\\n                    });\\n                }\\n                let scopes = tokenType;\\n                if (tokenModifiers) {\\n                    scopes += `.${tokenModifiers.join(\\\".\\\")}`;\\n                }\\n                tokens.push({\\n                    startIndex: start,\\n                    scopes: scopes,\\n                })\\n                prevEnd = end;\\n            })\\n            return {\\n                tokens: tokens,\\n                endState: state,\\n            }\\n        }\\n    })\\n    \\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"monaco\"},\"$:/plugins/smilyorg/monaco-wikitext/hover.js\":{\"title\":\"$:/plugins/smilyorg/monaco-wikitext/hover.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/smilyorg/monaco-wikitext/hover.js\\ntype: application/javascript\\nmodule-type: monaco\\n\\nWikitext hover support\\n\\n\\\\*/\\n(function(){\\n    \\\"use strict\\\";\\n\\n    const { monaco } = require(\\\"$:/plugins/smilyorg/monaco/monaco.js\\\");\\n    const { LANGUAGE_ID } = require(\\\"$:/plugins/smilyorg/monaco-wikitext/language.js\\\");\\n    const { extractTokensFromTree } = require(\\\"$:/plugins/smilyorg/monaco-wikitext/parser.js\\\");\\n\\n    let currentHoverTiddler = null;\\n    monaco.editor.registerCommand(\\\"open-tiddler\\\", () => {\\n        if (!currentHoverTiddler) return;\\n        $tw.wiki.addToStory(currentHoverTiddler);\\n    })\\n\\n    monaco.languages.registerHoverProvider(LANGUAGE_ID, {\\n        provideHover(model, position, _) {\\n            const text = model.getLineContent(position.lineNumber);\\n            const offset = position.column;\\n            const parsed = $tw.wiki.parseText(\\\"text/vnd.tiddlywiki\\\", text);\\n            \\n            const matchingNodes = [];\\n            extractTokensFromTree(parsed, (start, end, tokenType, tokenModifiers, node, parent) => {\\n                if (offset >= start && offset <= end && node) {\\n                    node.start = start;\\n                    node.end = end;\\n                    node.parent = parent;\\n                    matchingNodes.push(node);\\n                }\\n            })\\n            if (matchingNodes.length == 0) {\\n                return null;\\n            }\\n            const node = matchingNodes[0];\\n            return {\\n                range: {\\n                    startLineNumber: position.lineNumber,\\n                    startColumn: 1 + node.start,\\n                    endLineNumber: position.lineNumber,\\n                    endColumn: 1 + node.end,\\n                },\\n                contents: getHoverContentsFromNode(node),\\n            }\\n        }\\n    });\\n\\n    /**\\n     * Get hover contents based on tree node\\n     * @param {object} node \\n     * @returns \\n     */\\n     function getHoverContentsFromNode(node) {\\n        switch (node.type) {\\n            case \\\"text\\\":\\n                switch (node.parent.type) {\\n                    case \\\"link\\\":\\n                        if (node.parent.attributes.to.type == \\\"string\\\") {\\n                            const title = node.parent.attributes.to.value;\\n                            const html = $tw.wiki.renderTiddler(\\\"text/html\\\", title);\\n                            currentHoverTiddler = title;\\n                            return [\\n                                {\\n                                    isTrusted: true,\\n                                    value: `**[${title}](command:open-tiddler)**`,\\n                                },\\n                                {\\n                                    isTrusted: true,\\n                                    supportHtml: true,\\n                                    value: html || \\\"_Not found_\\\",\\n                                }\\n                            ]\\n                        }\\n                        return null;\\n                }\\n                break;\\n            case \\\"transclude\\\":\\n                if (node.attributes.tiddler.type == \\\"string\\\") {\\n                    const title = node.attributes.tiddler.value;\\n                    const html = $tw.wiki.renderTiddler(\\\"text/html\\\", title);\\n                    return [{\\n                        isTrusted: true,\\n                        supportHtml: true,\\n                        value: html\\n                    }]\\n                }\\n                break;\\n        }\\n        return null;\\n    }\\n    \\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"monaco\"},\"$:/plugins/smilyorg/monaco-wikitext/language.js\":{\"title\":\"$:/plugins/smilyorg/monaco-wikitext/language.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/smilyorg/monaco-wikitext/language.js\\ntype: application/javascript\\nmodule-type: monaco\\n\\nTiddlyWiki wikitext integration for Monaco\\n\\n\\\\*/\\n(function(){\\n\\n    /*jslint browser: true */\\n    /*global $tw: false */\\n    \\\"use strict\\\";\\n\\n    const LANGUAGE_ID = \\\"tiddlywiki-wikitext\\\";\\n\\n    const { monaco } = require(\\\"$:/plugins/smilyorg/monaco/monaco.js\\\");\\n    monaco.languages.register({ id: LANGUAGE_ID });\\n\\n    exports.LANGUAGE_ID  = LANGUAGE_ID;\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"monaco\"},\"$:/plugins/smilyorg/monaco-wikitext/license\":{\"title\":\"$:/plugins/smilyorg/monaco-wikitext/license\",\"text\":\"! tw5-monaco\\n\\nThe MIT License (MIT)\\n\\nCopyright (c) 2022 - present Miha Lunar\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\\n\\n! Third-Party Libraries\\n\\n!! Monaco Editor\\n\\nThe MIT License (MIT)\\n\\nCopyright (c) 2016 - present Microsoft Corporation\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\\n\\n\"},\"$:/plugins/smilyorg/monaco-wikitext/parser.js\":{\"title\":\"$:/plugins/smilyorg/monaco-wikitext/parser.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/smilyorg/monaco-wikitext/parser.js\\ntype: application/javascript\\nmodule-type: monaco\\n\\nWikitext enhanced parser support\\n\\n\\\\*/\\n(function(){\\n    \\\"use strict\\\";\\n\\n    /**\\n     * Get token type based on tree node\\n     * @param {object} node \\n     * @returns {string} token type\\n     */\\n     function getTokenType(node) {\\n        if (!node) return null;\\n        switch (node.type) {\\n            case \\\"element\\\":\\n                switch (node.tag) {\\n                    case \\\"h1\\\":\\n                    case \\\"h2\\\":\\n                    case \\\"h3\\\":\\n                    case \\\"h4\\\":\\n                    case \\\"h5\\\":\\n                    case \\\"h6\\\":\\n                        return \\\"header\\\"; \\n                    case \\\"a\\\":\\n                        return \\\"link\\\";\\n                }\\n                return `${node.type}-${node.tag}`;\\n        }\\n        return node.type;\\n    }\\n\\n    /**\\n     * Get token modifiers based on tree node\\n     * @param {object} node \\n     * @returns {string} token type\\n     */\\n    function getTokenModifiers(node) {\\n        if (!node) return null;\\n        switch (node.type) {\\n            case \\\"link\\\":\\n                const tiddler = $tw.wiki.getTiddler(node.attributes.to.value);\\n                if (!tiddler) {\\n                    return [\\\"broken\\\"];\\n                }\\n                return null;\\n        }\\n        return null;\\n    }\\n\\n    /**\\n     * Extract tokens from the TiddlyWiki parser node tree,\\n     * applying heuristics for missing ranges.\\n     * \\n     * @param {object} parsed TiddlyWiki parser result\\n     * @param {function} onToken Called for each token\\n     */\\n    function extractTokensFromTree(parsed, onToken) {\\n        const tree = parsed.tree;\\n        const stackIndex = [0];\\n        const stackNodes = [tree];\\n        let searchStackIndex = [];\\n        let searchStackNodes = [];\\n        let depth = 0;\\n        let lastEnd = 0;\\n        while (true) {\\n            const index = stackIndex[depth];\\n            const nodes = stackNodes[depth];\\n            // prewalk right\\n            stackIndex[depth]++;\\n            if (index >= nodes.length) {\\n                // walk up\\n                depth--;\\n                if (depth < 0) {\\n                    break;\\n                }\\n                continue;\\n            }\\n\\n            const node = nodes[index];\\n            const children = node.children;\\n\\n            if (children) {\\n                // walk down\\n                depth++;\\n                stackIndex[depth] = 0;\\n                stackNodes[depth] = children;\\n                continue\\n            }\\n\\n            let nodeStart = node.start;\\n            let nodeEnd = node.end;\\n\\n            // If the start position is not available, travel\\n            // up the tree and find the closest possible edge\\n            // to use as the start position of the range\\n            if (nodeStart === undefined) {\\n                let searchDepth = depth;\\n                for (let i = 0; i <= searchDepth; i++) {\\n                    searchStackIndex[i] = stackIndex[i];\\n                    searchStackNodes[i] = stackNodes[i];\\n                }\\n                while (true) {\\n                    searchStackIndex[searchDepth]--;\\n                    const searchIndex = searchStackIndex[searchDepth];\\n                    const searchNodes = searchStackNodes[searchDepth];\\n                    if (searchIndex < 0) {\\n                        searchDepth--;\\n                        if (searchDepth < 0) {\\n                            nodeStart = 0;\\n                            break;\\n                        }\\n                        continue;\\n                    }\\n                    const searchNode = searchNodes[searchIndex];\\n                    if (searchNode.end !== undefined) {\\n                        let ancestor = false;\\n                        for (let i = depth; i >= 0; i--) {\\n                            if (searchNode == stackNodes[i][stackIndex[i] - 1]) {\\n                                ancestor = true;\\n                                break;\\n                            }\\n                        }\\n                        nodeStart = ancestor ? searchNode.start : searchNode.end;\\n                        break;\\n                    }\\n                    if (searchNode.children?.length > 0) {\\n                        searchDepth++;\\n                        searchStackIndex[searchDepth] = 0;\\n                        searchStackNodes[searchDepth] = searchNode.children;\\n                        continue;\\n                    }\\n                }\\n            }\\n\\n            // If the end position is not available, travel\\n            // down the tree and find the closest possible edge\\n            // to use as the end position of the range\\n            if (nodeEnd === undefined) {\\n                let searchDepth = depth;\\n                for (let i = 0; i <= searchDepth; i++) {\\n                    searchStackIndex[i] = stackIndex[i];\\n                    searchStackNodes[i] = stackNodes[i];\\n                }\\n                while (true) {\\n                    const searchIndex = searchStackIndex[searchDepth];\\n                    const searchNodes = searchStackNodes[searchDepth];\\n                    searchStackIndex[searchDepth] = searchIndex + 1;\\n                    if (searchIndex >= searchNodes.length) {\\n                        searchDepth--;\\n                        if (searchDepth < 0) {\\n                            nodeEnd = parsed.source.length;\\n                            break;\\n                        }\\n                        continue;\\n                    }\\n                    const searchNode = searchNodes[searchIndex];\\n                     if (searchNode.start !== undefined) {\\n                        let ancestor = false;\\n                        for (let i = depth; i >= 0; i--) {\\n                            if (searchNode == stackNodes[i][stackIndex[i] - 1]) {\\n                                ancestor = true;\\n                                break;\\n                            }\\n                        }\\n                        nodeEnd = ancestor ? searchNode.end : searchNode.start;\\n                        break;\\n                    }\\n                    if (searchNode.children?.length > 0) {\\n                        searchDepth++;\\n                        searchStackIndex[searchDepth] = 0;\\n                        searchStackNodes[searchDepth] = searchNode.children;\\n                        continue;\\n                    }\\n                }\\n            }\\n            \\n            // Ignore nodes without a valid range\\n            if (nodeStart === undefined && nodeEnd === undefined) {\\n                continue;\\n            }\\n        \\n            let tokenType = null;\\n            let tokenModifiers = null;\\n\\n            const parent = depth == 0 ? null : stackNodes[depth - 1][stackIndex[depth - 1] - 1];\\n            switch (node.type) {\\n                case \\\"text\\\":\\n                    tokenType = getTokenType(parent);\\n                    tokenModifiers = getTokenModifiers(parent);\\n                    break;\\n                default:\\n                    tokenType = getTokenType(node);\\n                    tokenModifiers = getTokenModifiers(node);\\n            }\\n\\n            if (nodeStart < lastEnd) {\\n                console.warn(\\\"overlapping token, last ended\\\", lastEnd, \\\"next starting\\\", nodeStart, node);\\n            }\\n            \\n            // Ignore unknown tokens\\n            if (tokenType === null) {\\n                continue;\\n            }\\n\\n            // See if we can find formatting characters to split them out\\n            // as separate tokens for de-emphasis\\n            let prefix = null;\\n            let suffix = null;\\n            switch (tokenType) {\\n                case \\\"element-em\\\":      prefix = \\\"//\\\"; suffix = \\\"//\\\"; break;\\n                case \\\"element-u\\\":       prefix = \\\"__\\\"; suffix = \\\"__\\\"; break;\\n                case \\\"element-strong\\\":  prefix = \\\"''\\\"; suffix = \\\"''\\\"; break;\\n                case \\\"element-sup\\\":     prefix = \\\"^^\\\"; suffix = \\\"^^\\\"; break;\\n                case \\\"element-sub\\\":     prefix = \\\",,\\\"; suffix = \\\",,\\\"; break;\\n                case \\\"element-strike\\\":  prefix = \\\"~~\\\"; suffix = \\\"~~\\\"; break;\\n                case \\\"link\\\":            prefix = \\\"[[\\\"; suffix = \\\"]]\\\"; break;\\n                case \\\"transclude\\\":      prefix = \\\"{{\\\"; suffix = \\\"}}\\\"; break;\\n            }\\n\\n            // Try to split out prefix and suffix\\n            let wrapperFound = false;\\n            let middleStart = nodeStart;\\n            let middleEnd = nodeEnd;\\n            const source = parsed.source;\\n\\n            // Match expected prefix and suffix, both inset if the token\\n            // includes them, like >__text__< and outset if they wrap\\n            // the token, like __>text<__\\n            if (!prefix || !suffix) {}\\n            else if (\\n                prefix == source.substring(nodeStart, nodeStart + prefix.length) &&\\n                suffix == source.substring(nodeEnd - suffix.length, nodeEnd)\\n            ) {\\n                wrapperFound = true;\\n                middleStart = nodeStart + prefix.length;\\n                middleEnd = nodeEnd - suffix.length;\\n            } else if (\\n                prefix == source.substring(nodeStart - prefix.length, nodeStart) &&\\n                suffix == source.substring(nodeEnd, nodeEnd + suffix.length)\\n            ) {\\n                wrapperFound = true;\\n            }\\n\\n            // Output prefix token if found\\n            if (wrapperFound) {\\n                onToken(middleStart - prefix.length, middleStart, \\\"punctuation\\\", [\\\"start\\\"]);     \\n            }\\n\\n            // Process the middle part\\n            switch (tokenType) {\\n                case \\\"link\\\":\\n                    if (source.substring(middleStart, middleStart + node.text.length + 1) == node.text + \\\"|\\\") {\\n                        // Split the text and title as part of a [[text|title]] link\\n                        onToken(middleStart, middleStart + node.text.length, tokenType, tokenModifiers, node, parent);\\n                        onToken(middleStart + node.text.length, middleStart + node.text.length + 1, \\\"punctuation\\\", [\\\"middle\\\"], node, parent);\\n                        onToken(middleStart + node.text.length + 1, middleEnd, tokenType, [\\\"title\\\"].concat(tokenModifiers), node, parent);\\n                    } else {\\n                        onToken(middleStart, middleEnd, tokenType, tokenModifiers, node, parent);\\n                    }\\n                    break;\\n                default:\\n                    onToken(middleStart, middleEnd, tokenType, tokenModifiers, node, parent);\\n            }\\n\\n            // Output suffix token if found\\n            if (wrapperFound) {\\n                onToken(middleEnd, middleEnd + suffix.length, \\\"punctuation\\\", [\\\"end\\\"]);     \\n            }\\n\\n            lastEnd = nodeEnd;\\n        }\\n    }\\n\\n    Object.assign(exports, {\\n        getTokenType,\\n        getTokenModifiers,\\n        extractTokensFromTree,\\n    });\\n    \\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"monaco\"},\"$:/plugins/smilyorg/monaco-wikitext/readme\":{\"title\":\"$:/plugins/smilyorg/monaco-wikitext/readme\",\"text\":\"Wikitext `text/vnd.tiddlywiki` support for $:/plugins/smilyorg/monaco\\n\"}}}","revision":"0","bag":"default"}