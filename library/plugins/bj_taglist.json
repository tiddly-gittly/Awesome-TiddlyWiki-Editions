{"type":"application/json","text":"{\n    \"tiddlers\": {\n        \"$:/core/modules/widgets/button-dragover-extend.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/button-dragover-extend.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nExtend the link widget to allow click when there is a drag over (option)\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar ButtonWidget = require(\\\"$:/core/modules/widgets/button.js\\\")[\\\"button\\\"];\\nButtonWidget.prototype.bjDragExtend ={};\\nButtonWidget.prototype.bjDragExtend.render = ButtonWidget.prototype.render;\\n\\nButtonWidget.prototype.render = function (parent,nextSibling) {\\n\\tButtonWidget.prototype.bjDragExtend.render.call(this,parent,nextSibling);\\n\\tif (this.dragoverclick===\\\"yes\\\") { \\n\\t\\t$tw.utils.addEventListeners(this.domNodes[0],[\\n\\t\\t\\t{name: \\\"dragover\\\", handlerObject: this, handlerMethod: \\\"handleDragOverEvent\\\"}\\n\\t\\t]);\\n\\t}\\n}\\n\\n/*\\nadd option\\n*/\\nButtonWidget.prototype.bjDragExtend.execute = ButtonWidget.prototype.execute;\\nButtonWidget.prototype.execute = function() {\\n\\tButtonWidget.prototype.bjDragExtend.execute.call(this);\\n\\tthis.dragoverclick=this.getAttribute(\\\"dragoverclick\\\",\\\"no\\\");\\n};\\n/*\\nhandle dragover\\n*/\\nButtonWidget.prototype.handleDragOverEvent  = function(event) {\\n\\t// Tell the browser that we're still interested in the drop\\n\\tevent.preventDefault();\\n\\t// Send the drag as click  as a navigate event\\n\\tvar bounds = this.domNodes[0].getBoundingClientRect();\\n\\tthis.dispatchEvent({\\n\\t\\ttype: \\\"tm-navigate\\\",\\n\\t\\tnavigateTo: this.to,\\n\\t\\tnavigateFromTitle: this.getVariable(\\\"storyTiddler\\\"),\\n\\t\\tnavigateFromNode: this,\\n\\t\\tnavigateFromClientRect: { top: bounds.top, left: bounds.left, width: bounds.width, right: bounds.right, bottom: bounds.bottom, height: bounds.height\\n\\t\\t},\\n\\t\\tnavigateSuppressNavigation: event.metaKey || event.ctrlKey\\n\\t});\\n\\tevent.preventDefault();\\n\\tevent.stopPropagation();\\n\\treturn false;\\n};\\n})();\\n\",\n            \"title\": \"$:/core/modules/widgets/button-dragover-extend.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/core/modules/widgets/dropzone-extend.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/dropzone-extend.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nExtend the dropzone widget to allow other widget to handle drop events \\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\n\\nvar DropZoneWidget = require(\\\"$:/core/modules/widgets/dropzone.js\\\")[\\\"dropzone\\\"];\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n/*\\nThe edit-text widget calls this method just after inserting its dom nodes\\n*/\\n/*\\noverload the base widget class initialise\\n*/\\nDropZoneWidget.prototype.bjDropzoneExtend ={};\\nDropZoneWidget.prototype.bjDropzoneExtend.initialise = DropZoneWidget.prototype.initialise;\\n\\nDropZoneWidget.prototype.initialise = function (parseTreeNode,options) {\\n\\tDropZoneWidget.prototype.bjDropzoneExtend.initialise.call(this,parseTreeNode,options);\\n\\tthis.addEventListeners([\\n\\t\\t{type: \\\"tw-dropHandled\\\", handler: \\\"handleDropHandled\\\"}]);\\n};\\n/*\\nhandle drophandled message\\n*/\\nDropZoneWidget.prototype.handleDropHandled = function(event) {\\n\\t// Reset the enter count\\n\\tthis.dragEnterCount = 0;\\n\\t// Remove highlighting\\n\\t$tw.utils.removeClass(this.domNodes[0],\\\"tc-dragover\\\");\\n\\treturn false;\\n};\\n\\n})();\\n\",\n            \"title\": \"$:/core/modules/widgets/dropzone-extend.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/core/modules/widgets/link-dragover-extend.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/link-dragover-extend.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nExtend the link widget to allow click when there is a drag over (option)\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar LinkWidget = require(\\\"$:/core/modules/widgets/link.js\\\")[\\\"link\\\"];\\nLinkWidget.prototype.bjDragExtend ={};\\nLinkWidget.prototype.bjDragExtend.renderLink = LinkWidget.prototype.renderLink;\\n\\nLinkWidget.prototype.renderLink = function (parent,nextSibling) {\\n\\tLinkWidget.prototype.bjDragExtend.renderLink.call(this,parent,nextSibling);\\n\\tif (this.dragoverclick===\\\"yes\\\") { \\n\\t\\t$tw.utils.addEventListeners(this.domNodes[0],[\\n\\t\\t\\t{name: \\\"dragover\\\", handlerObject: this, handlerMethod: \\\"handleDragOverEvent\\\"}\\n\\t\\t]);\\n\\t}\\n}\\n\\n/*\\nadd option\\n*/\\nLinkWidget.prototype.bjDragExtend.execute = LinkWidget.prototype.execute;\\nLinkWidget.prototype.execute = function() {\\n\\tLinkWidget.prototype.bjDragExtend.execute.call(this);\\n\\tthis.dragoverclick=this.getAttribute(\\\"dragoverclic\\\",\\\"no\\\");\\n};\\n/*\\nhandle dragover\\n*/\\nLinkWidget.prototype.handleDragOverEvent  = function(event) {\\n\\t// Tell the browser that we're still interested in the drop\\n\\tevent.preventDefault();\\n\\t// Send the drag as click  as a navigate event\\n\\tvar bounds = this.domNodes[0].getBoundingClientRect();\\n\\tthis.dispatchEvent({\\n\\t\\ttype: \\\"tm-navigate\\\",\\n\\t\\tnavigateTo: this.to,\\n\\t\\tnavigateFromTitle: this.getVariable(\\\"storyTiddler\\\"),\\n\\t\\tnavigateFromNode: this,\\n\\t\\tnavigateFromClientRect: { top: bounds.top, left: bounds.left, width: bounds.width, right: bounds.right, bottom: bounds.bottom, height: bounds.height\\n\\t\\t},\\n\\t\\tnavigateSuppressNavigation: event.metaKey || event.ctrlKey\\n\\t});\\n\\tevent.preventDefault();\\n\\tevent.stopPropagation();\\n\\treturn false;\\n};\\n})();\\n\",\n            \"title\": \"$:/core/modules/widgets/link-dragover-extend.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        },\n        \"$:/core/modules/widgets/taglist.js\": {\n            \"text\": \"/*\\\\\\ntitle: $:/core/modules/widgets/taglist.js\\ntype: application/javascript\\nmodule-type: widget\\n\\nList and list item widgets\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n\\n/*\\nThe list widget creates list element sub-widgets that reach back into the list widget for their configuration\\n*/\\n\\nvar TagListWidget = function(parseTreeNode,options) {\\n\\t// Initialise the storyviews if they've not been done already\\n\\tif(!this.storyViews) {\\n\\t\\tTagListWidget.prototype.storyViews = {};\\n\\t\\t$tw.modules.applyMethods(\\\"storyview\\\",this.storyViews);\\n\\t}\\n\\t// Main initialisation inherited from widget.js\\n\\tthis.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nTagListWidget.prototype = new Widget();\\n\\n/*\\nRender this widget into the DOM\\n*/\\nTagListWidget.prototype.render = function(parent,nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\n\\tthis.renderChildren(parent,nextSibling);\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nTagListWidget.prototype.execute = function() {\\n\\t// Get our attributes\\n\\tthis.template = this.getAttribute(\\\"template\\\");\\n\\tthis.editTemplate = this.getAttribute(\\\"editTemplate\\\");\\n\\tthis.variableName = this.getAttribute(\\\"variable\\\",\\\"currentTiddler\\\");\\n\\tthis.nodrop = this.getAttribute(\\\"nodrop\\\");\\n\\tthis.listtag=this.getAttribute(\\\"targeTtag\\\",this.getVariable(\\\"currentTiddler\\\"));\\n\\t// Compose the list elements\\n\\tthis.list = this.getTiddlerList();\\n\\tvar members = [],\\n\\t\\tself = this;\\n\\t// Check for an empty list\\n\\tif(this.list.length === 0) {\\n\\t\\tmembers = this.getEmptyMessage();\\n\\t} else {\\n\\t\\t$tw.utils.each(this.list,function(title,index) {\\n\\t\\t\\tmembers.push(self.makeItemTemplate(title));\\n\\t\\t});\\n\\t}\\n\\t// Construct the child widgets\\n\\tthis.makeChildWidgets(members);\\n};\\n\\nTagListWidget.prototype.getTiddlerList = function() {\\n\\tvar defaultFilter = \\\"[tag[\\\"+this.listtag+\\\"]]\\\";\\n\\treturn this.wiki.filterTiddlers(this.getAttribute(\\\"filter\\\",defaultFilter),this);//BJ FIXME should not allow user defined filters\\n};\\nTagListWidget.prototype.setTiddlerList = function(what,where) {\\n\\tvar self = this;\\n\\tif (this.nodrop) return;\\n\\tvar update = function(value) {\\n\\t\\tvar tiddler = self.wiki.getTiddler(self.listtag)||{title:self.listtag},\\n\\t\\t\\tupdateFields = {};\\n\\t\\t\\n\\t\\tupdateFields[\\\"list\\\"] = value;\\n\\t\\tself.wiki.addTiddler(new $tw.Tiddler(self.wiki.getCreationFields(),tiddler,updateFields,\\n\\t\\tself.wiki.getModificationFields()));\\n\\t};\\n\\tvar newlist=[],\\n\\t\\tj=0;\\n\\t\\n\\tfor (var i=0;i<this.list.length;i++) {\\n\\t\\tif (this.list[i]===what) continue;\\n\\t\\tif (this.list[i]===where) {\\n\\t\\t\\tnewlist[j]=what;\\n\\t\\t\\tj++; \\n\\t\\t}\\n\\t\\tnewlist[j]=this.list[i];\\n\\t\\tj++; \\n\\t}\\n\\tupdate(newlist);\\n};\\n\\nTagListWidget.prototype.getEmptyMessage = function() {\\n\\tvar emptyMessage = this.getAttribute(\\\"emptyMessage\\\",\\\"\\\"),\\n\\t\\tparser = this.wiki.parseText(\\\"text/vnd.tiddlywiki\\\",emptyMessage,{parseAsInline: true});\\n\\tif(parser) {\\n\\t\\treturn parser.tree;\\n\\t} else {\\n\\t\\treturn [];\\n\\t}\\n};\\n\\n/*\\nCompose the template for a list item\\n*/\\nTagListWidget.prototype.makeItemTemplate = function(title) {\\n\\t// Check if the tiddler is a draft\\n\\tvar tiddler = this.wiki.getTiddler(title),\\n\\t\\tisDraft = tiddler && tiddler.hasField(\\\"draft.of\\\"),\\n\\t\\ttemplate = this.template,\\n\\t\\ttemplateTree;\\n\\tif(isDraft && this.editTemplate) {\\n\\t\\ttemplate = this.editTemplate;\\n\\t}\\n\\t// Compose the transclusion of the template\\n\\tif(template) {\\n\\t\\ttemplateTree = [{type: \\\"transclude\\\", attributes: {tiddler: {type: \\\"string\\\", value: template}}}];\\n\\t} else {\\n\\t\\tif(this.parseTreeNode.children && this.parseTreeNode.children.length > 0) {\\n\\t\\t\\ttemplateTree = this.parseTreeNode.children;\\n\\t\\t} else {\\n\\t\\t\\t// Default template is a link to the title\\n\\t\\t\\ttemplateTree = [{type: \\\"element\\\", tag: this.parseTreeNode.isBlock ? \\\"div\\\" : \\\"span\\\", children: [{type: \\\"link\\\", attributes: {to: {type: \\\"string\\\", value: title}}, children: [\\n\\t\\t\\t\\t\\t{type: \\\"text\\\", text: title}\\n\\t\\t\\t]}]}];\\n\\t\\t}\\n\\t}\\n\\t// Return the list item\\n\\treturn {type: \\\"taglistitem\\\", itemTitle: title, variableName: this.variableName, children: templateTree, listtag:this.listtag};\\n};\\n\\n/*\\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n*/\\nTagListWidget.prototype.refresh = function(changedTiddlers) {\\n\\tvar changedAttributes = this.computeAttributes();\\n\\t// Completely refresh if any of our attributes have changed\\n\\tif(changedAttributes.filter || changedAttributes.template || changedAttributes.editTemplate || changedAttributes.emptyMessage || changedAttributes.storyview || changedAttributes.targeTtag) {\\n\\t\\tthis.refreshSelf();\\n\\t\\treturn true;\\n\\t} else {\\n\\t\\t// Handle any changes to the list\\n\\t\\tvar hasChanged = this.handleListChanges(changedTiddlers);\\n\\t\\treturn hasChanged;\\n\\t}\\n};\\n\\n\\n/*\\nProcess any changes to the list\\n*/\\nTagListWidget.prototype.handleListChanges = function(changedTiddlers) {\\n\\t// Get the new list\\n\\tvar prevList = this.list;\\n\\tthis.list = this.getTiddlerList();//alert(this.list);\\n\\tvar redolist = false;\\n\\n\\t// Check for an empty list\\n\\tif(this.list.length === 0) {\\n\\t\\t// Check if it was empty before\\n\\t\\tif(prevList.length === 0) {\\n\\t\\t\\t// If so, just refresh the empty message\\n\\t\\t\\treturn this.refreshChildren(changedTiddlers);\\n\\t\\t} else {\\n\\t\\t\\t// Replace the previous content with the empty message\\n\\t\\t\\tfor(var t=this.children.length-1; t>=0; t--) {\\n\\t\\t\\t\\tthis.removeListItem(t);\\n\\t\\t\\t}\\n\\t\\t\\tvar nextSibling = this.findNextSiblingDomNode();\\n\\t\\t\\tthis.makeChildWidgets(this.getEmptyMessage());\\n\\t\\t\\tthis.renderChildren(this.parentDomNode,nextSibling);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t} else {\\n\\t\\t// If the list was empty then we need to remove the empty message\\n\\t\\tif(prevList.length === 0) \\n\\t\\t{\\n\\t\\t\\tthis.removeChildDomNodes();\\n\\t\\t\\tthis.children = [];\\n\\t\\t}\\n\\t\\tif (prevList.length!==this.list.length) {\\n\\t\\t\\tredolist = true;\\n\\t\\t} else {\\n\\t\\t\\tvar t;\\n\\t\\t\\tfor(t=0; t<this.list.length; t++) {\\n\\t\\t\\t\\tif (prevList[t]!==this.list[t]) {//compare tid titles\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t}\\n\\t\\t\\tif ( t!==this.list.length ){\\n\\t\\t\\t\\tredolist = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar hasRefreshed = false;\\n\\t\\tif (redolist === true) {\\n\\t\\t\\tvar hasRefreshed = true;\\n\\t\\t\\tfor(var t=this.children.length-1; t>=0; t--) {\\n\\t\\t\\t\\tthis.removeListItem(t);\\n\\t\\t\\t}\\n\\t\\t\\tfor(var t=0; t<this.list.length; t++) {\\n\\t\\t\\t\\t\\tthis.insertListItem(t,this.list[t]);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\treturn this.refreshChildren(changedTiddlers);\\n\\t\\t}\\n\\t\\treturn hasRefreshed;\\n\\t}\\n};\\n\\n/*\\nFind the list item with a given title, starting from a specified position\\n*/\\nTagListWidget.prototype.findListItem = function(startIndex,title) {\\n\\twhile(startIndex < this.children.length) {\\n\\t\\tif(this.children[startIndex].parseTreeNode.itemTitle === title) {\\n\\t\\t\\treturn startIndex;\\n\\t\\t}\\n\\t\\tstartIndex++;\\n\\t}\\n\\treturn undefined;\\n};\\n\\n/*\\nInsert a new list item at the specified index\\n*/\\nTagListWidget.prototype.insertListItem = function(index,title) {\\n\\t// Create, insert and render the new child widgets\\n\\tvar widget = this.makeChildWidget(this.makeItemTemplate(title));\\n\\twidget.parentDomNode = this.parentDomNode; // Hack to enable findNextSiblingDomNode() to work\\n\\tthis.children.splice(index,0,widget);\\n\\tvar nextSibling = widget.findNextSiblingDomNode();\\n\\twidget.render(this.parentDomNode,nextSibling);\\n\\t// Animate the insertion if required\\n\\tif(this.storyview && this.storyview.insert) {\\n\\t\\tthis.storyview.insert(widget);\\n\\t}\\n\\treturn true;\\n};\\n\\n/*\\nRemove the specified list item\\n*/\\nTagListWidget.prototype.removeListItem = function(index) {\\n\\tvar widget = this.children[index];\\n\\t// Animate the removal if required\\n\\tif(this.storyview && this.storyview.remove) {\\n\\t\\tthis.storyview.remove(widget);\\n\\t} else {\\n\\t\\twidget.removeChildDomNodes();\\n\\t}\\n\\t// Remove the child widget\\n\\tthis.children.splice(index,1);\\n};\\n\\nexports.taglist = TagListWidget;\\n\\nvar TagListItemWidget = function(parseTreeNode,options) {\\n\\tthis.initialise(parseTreeNode,options);\\n};\\n\\n/*\\nInherit from the base widget class\\n*/\\nTagListItemWidget.prototype = new Widget();\\nTagListItemWidget.prototype.addTag = function (tidname) {\\n\\t\\tvar tiddler = this.wiki.getTiddler(tidname);\\n\\t\\tvar modification = this.wiki.getModificationFields();\\n\\t\\tmodification.tags = (tiddler.fields.tags || []).slice(0);\\n\\t\\t$tw.utils.pushTop(modification.tags,this.parseTreeNode.listtag);\\n\\t\\tthis.wiki.addTiddler(new $tw.Tiddler(tiddler,modification));\\n\\t\\t\\t\\n}\\nTagListItemWidget.prototype.handleDropEvent  = function(event) {\\n\\tvar self = this,\\n\\t\\tdataTransfer = event.dataTransfer,\\n\\t\\treturned = this.nameandOnListTag(dataTransfer);\\n\\t\\n\\tif (!!returned.name) { //only handle tiddler drops\\n\\t\\t if (!returned.onList) { //this means tiddler does not have the tag\\n\\t\\t\\t this.addTag(returned.name);\\n\\t\\t }\\n\\t\\t this.parentWidget.setTiddlerList(returned.name, this.parseTreeNode.itemTitle);\\n\\n\\t\\t //cancel normal action\\n\\t\\t this.cancelAction(event);\\n\\t\\t self.dispatchEvent({type: \\\"tw-dropHandled\\\", param: null});\\n\\n\\t }\\n\\t //else let the event fall thru\\n};\\nTagListItemWidget.prototype.importDataTypes = [\\n\\t{type: \\\"text/vnd.tiddler\\\", IECompatible: false, convertToFields: function(data) {\\n\\t\\treturn JSON.parse(data);\\n\\t}},\\n\\t{type: \\\"URL\\\", IECompatible: true, convertToFields: function(data) {\\n\\t\\t// Check for tiddler data URI\\n\\t\\tvar match = decodeURI(data).match(/^data\\\\:text\\\\/vnd\\\\.tiddler,(.*)/i);\\n\\t\\tif(match) {\\n\\t\\t\\treturn JSON.parse(match[1]);\\n\\t\\t} else {\\n\\t\\t\\treturn { // As URL string\\n\\t\\t\\t\\ttext: data\\n\\t\\t\\t};\\n\\t\\t}\\n\\t}},\\n\\t{type: \\\"text/x-moz-url\\\", IECompatible: false, convertToFields: function(data) {\\n\\t\\t// Check for tiddler data URI\\n\\t\\tvar match = decodeURI(data).match(/^data\\\\:text\\\\/vnd\\\\.tiddler,(.*)/i);\\n\\t\\tif(match) {\\n\\t\\t\\treturn JSON.parse(match[1]);\\n\\t\\t} else {\\n\\t\\t\\treturn { // As URL string\\n\\t\\t\\t\\ttext: data\\n\\t\\t\\t};\\n\\t\\t}\\n\\t}},\\n\\t{type: \\\"text/plain\\\", IECompatible: false, convertToFields: function(data) {\\n\\t\\treturn {\\n\\t\\t\\ttext: data\\n\\t\\t};\\n\\t}},\\n\\t{type: \\\"Text\\\", IECompatible: true, convertToFields: function(data) {\\n\\t\\treturn {\\n\\t\\t\\ttext: data\\n\\t\\t};\\n\\t}},\\n\\t{type: \\\"text/uri-list\\\", IECompatible: false, convertToFields: function(data) {\\n\\t\\treturn {\\n\\t\\t\\ttext: data\\n\\t\\t};\\n\\t}}\\n];\\nTagListItemWidget.prototype.cancelAction =function(event) {\\n\\t// Try each provided data type in turn\\n\\t\\t{\\n\\tvar self = this,\\n\\t\\tdataTransfer = event.dataTransfer;\\n\\tevent.preventDefault();\\n\\t// Stop the drop ripple up to any parent handlers\\n\\tevent.stopPropagation();\\n};\\n};\\n\\n\\nTagListItemWidget.prototype.nameandOnListTag = function(dataTransfer) {\\n\\t// Try each provided data type in turn\\n\\tvar self = this;\\n\\tfor(var t=0; t<this.importDataTypes.length; t++) {\\n\\t\\tif(!$tw.browser.isIE || this.importDataTypes[t].IECompatible) {\\n\\t\\t\\t// Get the data\\n\\t\\t\\tvar dataType = this.importDataTypes[t];\\n\\t\\t\\tvar data = dataTransfer.getData(dataType.type);\\n\\t\\t\\t// Import the tiddlers in the data\\n\\t\\t\\tif(data !== \\\"\\\" && data !== null) {\\n\\t\\t\\t\\tvar tiddlerFields = dataType.convertToFields(data);\\n\\t\\t\\t\\tif(!tiddlerFields.title) {\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (tiddlerFields.tags && $tw.utils.parseStringArray(tiddlerFields.tags).indexOf(self.parseTreeNode.listtag) !== -1) {\\n\\t\\t\\t\\t\\treturn {name:tiddlerFields.title, onList:true};\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {//we have to add the tag to the tiddler\\n\\t\\t\\t\\t\\tif (!!self.wiki.getTiddler(tiddlerFields.title)){//tid is in this tw\\n\\t\\t\\t\\t\\t\\treturn {name:tiddlerFields.title, onList:false};\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t//return false; \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\treturn  {name:null, onList:false};\\n};\\n/*\\nRender this widget into the DOM\\n*/\\nTagListItemWidget.prototype.render = function(parent,nextSibling) {\\n\\tthis.parentDomNode = parent;\\n\\tthis.computeAttributes();\\n\\tthis.execute();\\nvar domNode = this.document.createElement(\\\"div\\\");\\n\\t// Add event handlers\\n\\t$tw.utils.addEventListeners(domNode,[\\n\\t\\t{name: \\\"drop\\\", handlerObject: this, handlerMethod: \\\"handleDropEvent\\\"}\\n\\t\\t]);\\n\\t// Insert element\\n\\tparent.insertBefore(domNode,nextSibling);\\n\\tthis.renderChildren(domNode,null);\\n\\t//this.domNodes.push(domNode);\\n};\\n\\n/*\\nCompute the internal state of the widget\\n*/\\nTagListItemWidget.prototype.execute = function() {\\n\\t// Set the current list item title\\n\\tthis.setVariable(this.parseTreeNode.variableName,this.parseTreeNode.itemTitle);\\n\\t// Construct the child widgets\\n\\tthis.makeChildWidgets();\\n};\\n\\n/*\\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\\n*/\\nTagListItemWidget.prototype.refresh = function(changedTiddlers) {\\n\\treturn this.refreshChildren(changedTiddlers);\\n};\\n\\nexports.taglistitem = TagListItemWidget;\\n\\n})();\\n\",\n            \"title\": \"$:/core/modules/widgets/taglist.js\",\n            \"type\": \"application/javascript\",\n            \"module-type\": \"widget\"\n        }\n    }\n}","author":"Jeffrey Wilkinson","bag":"default","core-version":">=5.0.16","created":"20140904132953936","dependents":"","description":"re-orderable list on a tag","plugin-type":"plugin","revision":"0","source":"https://github.com/buggyj/TW5-taglist","title":"$:/plugins/bj/taglist","version":"0.0.4","name":"taglist"}